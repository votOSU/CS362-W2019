Now Testing Random Adventurer
Test 1 of 600: Test Passed. 
Test 2 of 600: Test Passed. 
Test 3 of 600: Test Failed. 
Test 4 of 600: Test Failed. 
Test 5 of 600: Test Passed. 
Test 6 of 600: Test Failed. 
Test 7 of 600: Test Passed. 
Test 8 of 600: Test Failed. 
Test 9 of 600: Test Passed. 
Test 10 of 600: Test Passed. 
Test 11 of 600: Test Passed. 
Test 12 of 600: Test Passed. 
Test 13 of 600: Test Passed. 
Test 14 of 600: Test Passed. 
Test 15 of 600: Test Passed. 
Test 16 of 600: Test Passed. 
Test 17 of 600: Test Passed. 
Test 18 of 600: Test Passed. 
Test 19 of 600: Test Passed. 
Test 20 of 600: Test Failed. 
Test 21 of 600: Test Passed. 
Test 22 of 600: Test Failed. 
Test 23 of 600: Test Passed. 
Test 24 of 600: Test Passed. 
Test 25 of 600: Test Passed. 
Test 26 of 600: Test Passed. 
Test 27 of 600: Test Failed. 
Test 28 of 600: Test Passed. 
Test 29 of 600: Test Passed. 
Test 30 of 600: Test Failed. 
Test 31 of 600: Test Failed. 
Test 32 of 600: Test Passed. 
Test 33 of 600: Test Passed. 
Test 34 of 600: Test Passed. 
Test 35 of 600: Test Passed. 
Test 36 of 600: Test Passed. 
Test 37 of 600: Test Passed. 
Test 38 of 600: Test Failed. 
Test 39 of 600: Test Passed. 
Test 40 of 600: Test Passed. 
Test 41 of 600: Test Passed. 
Test 42 of 600: Test Failed. 
Test 43 of 600: Test Passed. 
Test 44 of 600: Test Failed. 
Test 45 of 600: Test Passed. 
Test 46 of 600: Test Passed. 
Test 47 of 600: Test Passed. 
Test 48 of 600: Test Passed. 
Test 49 of 600: Test Passed. 
Test 50 of 600: Test Passed. 
Test 51 of 600: Test Passed. 
Test 52 of 600: Test Passed. 
Test 53 of 600: Test Passed. 
Test 54 of 600: Test Passed. 
Test 55 of 600: Test Passed. 
Test 56 of 600: Test Passed. 
Test 57 of 600: Test Passed. 
Test 58 of 600: Test Failed. 
Test 59 of 600: Test Passed. 
Test 60 of 600: Test Passed. 
Test 61 of 600: Test Passed. 
Test 62 of 600: Test Passed. 
Test 63 of 600: Test Passed. 
Test 64 of 600: Test Passed. 
Test 65 of 600: Test Passed. 
Test 66 of 600: Test Failed. 
Test 67 of 600: Test Passed. 
Test 68 of 600: Test Passed. 
Test 69 of 600: Test Passed. 
Test 70 of 600: Test Passed. 
Test 71 of 600: Test Passed. 
Test 72 of 600: Test Passed. 
Test 73 of 600: Test Passed. 
Test 74 of 600: Test Passed. 
Test 75 of 600: Test Failed. 
Test 76 of 600: Test Passed. 
Test 77 of 600: Test Failed. 
Test 78 of 600: Test Passed. 
Test 79 of 600: Test Passed. 
Test 80 of 600: Test Passed. 
Test 81 of 600: Test Passed. 
Test 82 of 600: Test Passed. 
Test 83 of 600: Test Passed. 
Test 84 of 600: Test Passed. 
Test 85 of 600: Test Passed. 
Test 86 of 600: Test Passed. 
Test 87 of 600: Test Passed. 
Test 88 of 600: Test Passed. 
Test 89 of 600: Test Passed. 
Test 90 of 600: Test Passed. 
Test 91 of 600: Test Passed. 
Test 92 of 600: Test Passed. 
Test 93 of 600: Test Passed. 
Test 94 of 600: Test Passed. 
Test 95 of 600: Test Passed. 
Test 96 of 600: Test Passed. 
Test 97 of 600: Test Passed. 
Test 98 of 600: Test Passed. 
Test 99 of 600: Test Passed. 
Test 100 of 600: Test Failed. 
Test 101 of 600: Test Passed. 
Test 102 of 600: Test Failed. 
Test 103 of 600: Test Passed. 
Test 104 of 600: Test Passed. 
Test 105 of 600: Test Passed. 
Test 106 of 600: Test Passed. 
Test 107 of 600: Test Passed. 
Test 108 of 600: Test Passed. 
Test 109 of 600: Test Failed. 
Test 110 of 600: Test Passed. 
Test 111 of 600: Test Passed. 
Test 112 of 600: Test Passed. 
Test 113 of 600: Test Failed. 
Test 114 of 600: Test Failed. 
Test 115 of 600: Test Passed. 
Test 116 of 600: Test Passed. 
Test 117 of 600: Test Failed. 
Test 118 of 600: Test Passed. 
Test 119 of 600: Test Passed. 
Test 120 of 600: Test Passed. 
Test 121 of 600: Test Passed. 
Test 122 of 600: Test Failed. 
Test 123 of 600: Test Passed. 
Test 124 of 600: Test Passed. 
Test 125 of 600: Test Passed. 
Test 126 of 600: Test Passed. 
Test 127 of 600: Test Failed. 
Test 128 of 600: Test Passed. 
Test 129 of 600: Test Passed. 
Test 130 of 600: Test Passed. 
Test 131 of 600: Test Passed. 
Test 132 of 600: Test Passed. 
Test 133 of 600: Test Passed. 
Test 134 of 600: Test Passed. 
Test 135 of 600: Test Failed. 
Test 136 of 600: Test Failed. 
Test 137 of 600: Test Passed. 
Test 138 of 600: Test Passed. 
Test 139 of 600: Test Passed. 
Test 140 of 600: Test Passed. 
Test 141 of 600: Test Passed. 
Test 142 of 600: Test Failed. 
Test 143 of 600: Test Failed. 
Test 144 of 600: Test Passed. 
Test 145 of 600: Test Passed. 
Test 146 of 600: Test Passed. 
Test 147 of 600: Test Failed. 
Test 148 of 600: Test Passed. 
Test 149 of 600: Test Passed. 
Test 150 of 600: Test Passed. 
Test 151 of 600: Test Passed. 
Test 152 of 600: Test Passed. 
Test 153 of 600: Test Passed. 
Test 154 of 600: Test Passed. 
Test 155 of 600: Test Passed. 
Test 156 of 600: Test Failed. 
Test 157 of 600: Test Failed. 
Test 158 of 600: Test Passed. 
Test 159 of 600: Test Failed. 
Test 160 of 600: Test Passed. 
Test 161 of 600: Test Passed. 
Test 162 of 600: Test Failed. 
Test 163 of 600: Test Passed. 
Test 164 of 600: Test Failed. 
Test 165 of 600: Test Passed. 
Test 166 of 600: Test Failed. 
Test 167 of 600: Test Failed. 
Test 168 of 600: Test Passed. 
Test 169 of 600: Test Passed. 
Test 170 of 600: Test Passed. 
Test 171 of 600: Test Passed. 
Test 172 of 600: Test Passed. 
Test 173 of 600: Test Passed. 
Test 174 of 600: Test Passed. 
Test 175 of 600: Test Passed. 
Test 176 of 600: Test Passed. 
Test 177 of 600: Test Passed. 
Test 178 of 600: Test Passed. 
Test 179 of 600: Test Passed. 
Test 180 of 600: Test Failed. 
Test 181 of 600: Test Passed. 
Test 182 of 600: Test Failed. 
Test 183 of 600: Test Passed. 
Test 184 of 600: Test Passed. 
Test 185 of 600: Test Passed. 
Test 186 of 600: Test Passed. 
Test 187 of 600: Test Passed. 
Test 188 of 600: Test Passed. 
Test 189 of 600: Test Passed. 
Test 190 of 600: Test Failed. 
Test 191 of 600: Test Passed. 
Test 192 of 600: Test Passed. 
Test 193 of 600: Test Passed. 
Test 194 of 600: Test Failed. 
Test 195 of 600: Test Passed. 
Test 196 of 600: Test Passed. 
Test 197 of 600: Test Passed. 
Test 198 of 600: Test Passed. 
Test 199 of 600: Test Passed. 
Test 200 of 600: Test Passed. 
Test 201 of 600: Test Failed. 
Test 202 of 600: Test Passed. 
Test 203 of 600: Test Failed. 
Test 204 of 600: Test Failed. 
Test 205 of 600: Test Passed. 
Test 206 of 600: Test Passed. 
Test 207 of 600: Test Passed. 
Test 208 of 600: Test Passed. 
Test 209 of 600: Test Passed. 
Test 210 of 600: Test Passed. 
Test 211 of 600: Test Passed. 
Test 212 of 600: Test Passed. 
Test 213 of 600: Test Failed. 
Test 214 of 600: Test Passed. 
Test 215 of 600: Test Passed. 
Test 216 of 600: Test Passed. 
Test 217 of 600: Test Passed. 
Test 218 of 600: Test Passed. 
Test 219 of 600: Test Passed. 
Test 220 of 600: Test Passed. 
Test 221 of 600: Test Failed. 
Test 222 of 600: Test Passed. 
Test 223 of 600: Test Passed. 
Test 224 of 600: Test Passed. 
Test 225 of 600: Test Failed. 
Test 226 of 600: Test Passed. 
Test 227 of 600: Test Passed. 
Test 228 of 600: Test Failed. 
Test 229 of 600: Test Passed. 
Test 230 of 600: Test Passed. 
Test 231 of 600: Test Passed. 
Test 232 of 600: Test Passed. 
Test 233 of 600: Test Passed. 
Test 234 of 600: Test Passed. 
Test 235 of 600: Test Failed. 
Test 236 of 600: Test Passed. 
Test 237 of 600: Test Passed. 
Test 238 of 600: Test Passed. 
Test 239 of 600: Test Passed. 
Test 240 of 600: Test Passed. 
Test 241 of 600: Test Passed. 
Test 242 of 600: Test Passed. 
Test 243 of 600: Test Passed. 
Test 244 of 600: Test Passed. 
Test 245 of 600: Test Passed. 
Test 246 of 600: Test Passed. 
Test 247 of 600: Test Passed. 
Test 248 of 600: Test Passed. 
Test 249 of 600: Test Passed. 
Test 250 of 600: Test Passed. 
Test 251 of 600: Test Passed. 
Test 252 of 600: Test Passed. 
Test 253 of 600: Test Passed. 
Test 254 of 600: Test Passed. 
Test 255 of 600: Test Passed. 
Test 256 of 600: Test Passed. 
Test 257 of 600: Test Passed. 
Test 258 of 600: Test Passed. 
Test 259 of 600: Test Passed. 
Test 260 of 600: Test Passed. 
Test 261 of 600: Test Failed. 
Test 262 of 600: Test Failed. 
Test 263 of 600: Test Passed. 
Test 264 of 600: Test Passed. 
Test 265 of 600: Test Passed. 
Test 266 of 600: Test Passed. 
Test 267 of 600: Test Passed. 
Test 268 of 600: Test Passed. 
Test 269 of 600: Test Failed. 
Test 270 of 600: Test Passed. 
Test 271 of 600: Test Passed. 
Test 272 of 600: Test Passed. 
Test 273 of 600: Test Passed. 
Test 274 of 600: Test Failed. 
Test 275 of 600: Test Passed. 
Test 276 of 600: Test Failed. 
Test 277 of 600: Test Passed. 
Test 278 of 600: Test Passed. 
Test 279 of 600: Test Failed. 
Test 280 of 600: Test Passed. 
Test 281 of 600: Test Failed. 
Test 282 of 600: Test Passed. 
Test 283 of 600: Test Failed. 
Test 284 of 600: Test Passed. 
Test 285 of 600: Test Passed. 
Test 286 of 600: Test Passed. 
Test 287 of 600: Test Passed. 
Test 288 of 600: Test Passed. 
Test 289 of 600: Test Failed. 
Test 290 of 600: Test Passed. 
Test 291 of 600: Test Failed. 
Test 292 of 600: Test Passed. 
Test 293 of 600: Test Passed. 
Test 294 of 600: Test Failed. 
Test 295 of 600: Test Passed. 
Test 296 of 600: Test Passed. 
Test 297 of 600: Test Passed. 
Test 298 of 600: Test Passed. 
Test 299 of 600: Test Failed. 
Test 300 of 600: Test Passed. 
Test 301 of 600: Test Passed. 
Test 302 of 600: Test Passed. 
Test 303 of 600: Test Passed. 
Test 304 of 600: Test Passed. 
Test 305 of 600: Test Failed. 
Test 306 of 600: Test Passed. 
Test 307 of 600: Test Failed. 
Test 308 of 600: Test Failed. 
Test 309 of 600: Test Passed. 
Test 310 of 600: Test Passed. 
Test 311 of 600: Test Passed. 
Test 312 of 600: Test Failed. 
Test 313 of 600: Test Passed. 
Test 314 of 600: Test Passed. 
Test 315 of 600: Test Passed. 
Test 316 of 600: Test Passed. 
Test 317 of 600: Test Passed. 
Test 318 of 600: Test Passed. 
Test 319 of 600: Test Passed. 
Test 320 of 600: Test Passed. 
Test 321 of 600: Test Passed. 
Test 322 of 600: Test Failed. 
Test 323 of 600: Test Failed. 
Test 324 of 600: Test Passed. 
Test 325 of 600: Test Passed. 
Test 326 of 600: Test Passed. 
Test 327 of 600: Test Passed. 
Test 328 of 600: Test Passed. 
Test 329 of 600: Test Passed. 
Test 330 of 600: Test Passed. 
Test 331 of 600: Test Failed. 
Test 332 of 600: Test Passed. 
Test 333 of 600: Test Passed. 
Test 334 of 600: Test Passed. 
Test 335 of 600: Test Failed. 
Test 336 of 600: Test Failed. 
Test 337 of 600: Test Passed. 
Test 338 of 600: Test Failed. 
Test 339 of 600: Test Failed. 
Test 340 of 600: Test Passed. 
Test 341 of 600: Test Passed. 
Test 342 of 600: Test Passed. 
Test 343 of 600: Test Passed. 
Test 344 of 600: Test Passed. 
Test 345 of 600: Test Passed. 
Test 346 of 600: Test Passed. 
Test 347 of 600: Test Passed. 
Test 348 of 600: Test Passed. 
Test 349 of 600: Test Failed. 
Test 350 of 600: Test Passed. 
Test 351 of 600: Test Passed. 
Test 352 of 600: Test Passed. 
Test 353 of 600: Test Passed. 
Test 354 of 600: Test Passed. 
Test 355 of 600: Test Passed. 
Test 356 of 600: Test Passed. 
Test 357 of 600: Test Passed. 
Test 358 of 600: Test Passed. 
Test 359 of 600: Test Passed. 
Test 360 of 600: Test Failed. 
Test 361 of 600: Test Passed. 
Test 362 of 600: Test Passed. 
Test 363 of 600: Test Passed. 
Test 364 of 600: Test Passed. 
Test 365 of 600: Test Passed. 
Test 366 of 600: Test Failed. 
Test 367 of 600: Test Passed. 
Test 368 of 600: Test Passed. 
Test 369 of 600: Test Passed. 
Test 370 of 600: Test Passed. 
Test 371 of 600: Test Failed. 
Test 372 of 600: Test Passed. 
Test 373 of 600: Test Passed. 
Test 374 of 600: Test Passed. 
Test 375 of 600: Test Passed. 
Test 376 of 600: Test Passed. 
Test 377 of 600: Test Passed. 
Test 378 of 600: Test Passed. 
Test 379 of 600: Test Failed. 
Test 380 of 600: Test Passed. 
Test 381 of 600: Test Passed. 
Test 382 of 600: Test Passed. 
Test 383 of 600: Test Passed. 
Test 384 of 600: Test Passed. 
Test 385 of 600: Test Failed. 
Test 386 of 600: Test Passed. 
Test 387 of 600: Test Passed. 
Test 388 of 600: Test Passed. 
Test 389 of 600: Test Passed. 
Test 390 of 600: Test Failed. 
Test 391 of 600: Test Passed. 
Test 392 of 600: Test Passed. 
Test 393 of 600: Test Failed. 
Test 394 of 600: Test Passed. 
Test 395 of 600: Test Passed. 
Test 396 of 600: Test Passed. 
Test 397 of 600: Test Passed. 
Test 398 of 600: Test Passed. 
Test 399 of 600: Test Passed. 
Test 400 of 600: Test Passed. 
Test 401 of 600: Test Failed. 
Test 402 of 600: Test Passed. 
Test 403 of 600: Test Passed. 
Test 404 of 600: Test Passed. 
Test 405 of 600: Test Passed. 
Test 406 of 600: Test Passed. 
Test 407 of 600: Test Passed. 
Test 408 of 600: Test Passed. 
Test 409 of 600: Test Failed. 
Test 410 of 600: Test Passed. 
Test 411 of 600: Test Passed. 
Test 412 of 600: Test Passed. 
Test 413 of 600: Test Failed. 
Test 414 of 600: Test Passed. 
Test 415 of 600: Test Passed. 
Test 416 of 600: Test Passed. 
Test 417 of 600: Test Failed. 
Test 418 of 600: Test Passed. 
Test 419 of 600: Test Passed. 
Test 420 of 600: Test Passed. 
Test 421 of 600: Test Passed. 
Test 422 of 600: Test Failed. 
Test 423 of 600: Test Passed. 
Test 424 of 600: Test Passed. 
Test 425 of 600: Test Passed. 
Test 426 of 600: Test Passed. 
Test 427 of 600: Test Passed. 
Test 428 of 600: Test Passed. 
Test 429 of 600: Test Passed. 
Test 430 of 600: Test Passed. 
Test 431 of 600: Test Passed. 
Test 432 of 600: Test Passed. 
Test 433 of 600: Test Passed. 
Test 434 of 600: Test Passed. 
Test 435 of 600: Test Passed. 
Test 436 of 600: Test Passed. 
Test 437 of 600: Test Passed. 
Test 438 of 600: Test Passed. 
Test 439 of 600: Test Passed. 
Test 440 of 600: Test Passed. 
Test 441 of 600: Test Passed. 
Test 442 of 600: Test Passed. 
Test 443 of 600: Test Passed. 
Test 444 of 600: Test Failed. 
Test 445 of 600: Test Passed. 
Test 446 of 600: Test Failed. 
Test 447 of 600: Test Failed. 
Test 448 of 600: Test Passed. 
Test 449 of 600: Test Passed. 
Test 450 of 600: Test Passed. 
Test 451 of 600: Test Failed. 
Test 452 of 600: Test Failed. 
Test 453 of 600: Test Failed. 
Test 454 of 600: Test Passed. 
Test 455 of 600: Test Passed. 
Test 456 of 600: Test Passed. 
Test 457 of 600: Test Passed. 
Test 458 of 600: Test Passed. 
Test 459 of 600: Test Failed. 
Test 460 of 600: Test Passed. 
Test 461 of 600: Test Passed. 
Test 462 of 600: Test Passed. 
Test 463 of 600: Test Passed. 
Test 464 of 600: Test Passed. 
Test 465 of 600: Test Passed. 
Test 466 of 600: Test Passed. 
Test 467 of 600: Test Failed. 
Test 468 of 600: Test Passed. 
Test 469 of 600: Test Passed. 
Test 470 of 600: Test Failed. 
Test 471 of 600: Test Passed. 
Test 472 of 600: Test Passed. 
Test 473 of 600: Test Passed. 
Test 474 of 600: Test Passed. 
Test 475 of 600: Test Passed. 
Test 476 of 600: Test Passed. 
Test 477 of 600: Test Passed. 
Test 478 of 600: Test Failed. 
Test 479 of 600: Test Passed. 
Test 480 of 600: Test Passed. 
Test 481 of 600: Test Passed. 
Test 482 of 600: Test Passed. 
Test 483 of 600: Test Passed. 
Test 484 of 600: Test Passed. 
Test 485 of 600: Test Passed. 
Test 486 of 600: Test Passed. 
Test 487 of 600: Test Passed. 
Test 488 of 600: Test Passed. 
Test 489 of 600: Test Passed. 
Test 490 of 600: Test Passed. 
Test 491 of 600: Test Failed. 
Test 492 of 600: Test Passed. 
Test 493 of 600: Test Passed. 
Test 494 of 600: Test Failed. 
Test 495 of 600: Test Passed. 
Test 496 of 600: Test Passed. 
Test 497 of 600: Test Passed. 
Test 498 of 600: Test Passed. 
Test 499 of 600: Test Passed. 
Test 500 of 600: Test Passed. 
Test 501 of 600: Test Passed. 
Test 502 of 600: Test Passed. 
Test 503 of 600: Test Passed. 
Test 504 of 600: Test Passed. 
Test 505 of 600: Test Passed. 
Test 506 of 600: Test Passed. 
Test 507 of 600: Test Passed. 
Test 508 of 600: Test Passed. 
Test 509 of 600: Test Passed. 
Test 510 of 600: Test Passed. 
Test 511 of 600: Test Passed. 
Test 512 of 600: Test Passed. 
Test 513 of 600: Test Failed. 
Test 514 of 600: Test Failed. 
Test 515 of 600: Test Passed. 
Test 516 of 600: Test Passed. 
Test 517 of 600: Test Passed. 
Test 518 of 600: Test Passed. 
Test 519 of 600: Test Failed. 
Test 520 of 600: Test Failed. 
Test 521 of 600: Test Passed. 
Test 522 of 600: Test Passed. 
Test 523 of 600: Test Passed. 
Test 524 of 600: Test Passed. 
Test 525 of 600: Test Passed. 
Test 526 of 600: Test Passed. 
Test 527 of 600: Test Passed. 
Test 528 of 600: Test Failed. 
Test 529 of 600: Test Failed. 
Test 530 of 600: Test Passed. 
Test 531 of 600: Test Passed. 
Test 532 of 600: Test Passed. 
Test 533 of 600: Test Failed. 
Test 534 of 600: Test Passed. 
Test 535 of 600: Test Passed. 
Test 536 of 600: Test Passed. 
Test 537 of 600: Test Failed. 
Test 538 of 600: Test Passed. 
Test 539 of 600: Test Failed. 
Test 540 of 600: Test Failed. 
Test 541 of 600: Test Failed. 
Test 542 of 600: Test Passed. 
Test 543 of 600: Test Passed. 
Test 544 of 600: Test Passed. 
Test 545 of 600: Test Failed. 
Test 546 of 600: Test Passed. 
Test 547 of 600: Test Passed. 
Test 548 of 600: Test Passed. 
Test 549 of 600: Test Passed. 
Test 550 of 600: Test Passed. 
Test 551 of 600: Test Passed. 
Test 552 of 600: Test Passed. 
Test 553 of 600: Test Passed. 
Test 554 of 600: Test Passed. 
Test 555 of 600: Test Passed. 
Test 556 of 600: Test Passed. 
Test 557 of 600: Test Passed. 
Test 558 of 600: Test Failed. 
Test 559 of 600: Test Failed. 
Test 560 of 600: Test Passed. 
Test 561 of 600: Test Passed. 
Test 562 of 600: Test Passed. 
Test 563 of 600: Test Passed. 
Test 564 of 600: Test Passed. 
Test 565 of 600: Test Failed. 
Test 566 of 600: Test Failed. 
Test 567 of 600: Test Passed. 
Test 568 of 600: Test Passed. 
Test 569 of 600: Test Passed. 
Test 570 of 600: Test Passed. 
Test 571 of 600: Test Failed. 
Test 572 of 600: Test Passed. 
Test 573 of 600: Test Failed. 
Test 574 of 600: Test Passed. 
Test 575 of 600: Test Passed. 
Test 576 of 600: Test Passed. 
Test 577 of 600: Test Passed. 
Test 578 of 600: Test Passed. 
Test 579 of 600: Test Passed. 
Test 580 of 600: Test Passed. 
Test 581 of 600: Test Passed. 
Test 582 of 600: Test Passed. 
Test 583 of 600: Test Passed. 
Test 584 of 600: Test Passed. 
Test 585 of 600: Test Passed. 
Test 586 of 600: Test Failed. 
Test 587 of 600: Test Passed. 
Test 588 of 600: Test Passed. 
Test 589 of 600: Test Passed. 
Test 590 of 600: Test Passed. 
Test 591 of 600: Test Failed. 
Test 592 of 600: Test Passed. 
Test 593 of 600: Test Failed. 
Test 594 of 600: Test Passed. 
Test 595 of 600: Test Passed. 
Test 596 of 600: Test Passed. 
Test 597 of 600: Test Failed. 
Test 598 of 600: Test Failed. 
Test 599 of 600: Test Failed. 
Test 600 of 600: Test Passed. 

Total Sucess:   480
Total Fails:  120
Tests Complete
File 'randomtestadventurer.c'
Lines executed:100.00% of 40
Creating 'randomtestadventurer.c.gcov'

File 'dominion.c'
Lines executed:17.14% of 560
Branches executed:16.31% of 417
Taken at least once:13.91% of 417
Calls executed:7.37% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <math.h>
        -:    6:#include <stdlib.h>
        -:    7:
function compare called 27525 returned 100% blocks executed 83%
    27525:    8:int compare(const void* a, const void* b) {
    27525:    9:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   10:    return 1;
    27525:   11:  if (*(int*)a < *(int*)b)
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
     7340:   12:    return -1;
    20185:   13:  return 0;
        -:   14:}
        -:   15:
function newGame called 0 returned 0% blocks executed 0%
    #####:   16:struct gameState* newGame() {
    #####:   17:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   18:  return g;
        -:   19:}
        -:   20:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   21:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   22:		  int k8, int k9, int k10) {
    #####:   23:  int* k = malloc(10 * sizeof(int));
    #####:   24:  k[0] = k1;
    #####:   25:  k[1] = k2;
    #####:   26:  k[2] = k3;
    #####:   27:  k[3] = k4;
    #####:   28:  k[4] = k5;
    #####:   29:  k[5] = k6;
    #####:   30:  k[6] = k7;
    #####:   31:  k[7] = k8;
    #####:   32:  k[8] = k9;
    #####:   33:  k[9] = k10;
    #####:   34:  return k;
        -:   35:}
        -:   36:
function initializeGame called 600 returned 100% blocks executed 95%
      600:   37:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   38:		   struct gameState *state) {
        -:   39:
        -:   40:  int i;
        -:   41:  int j;
        -:   42:  int it;			
        -:   43:  //set up random number generator
      600:   44:  SelectStream(1);
call    0 returned 100%
      600:   45:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   46:  
        -:   47:  //check number of players
      600:   48:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   49:    {
    #####:   50:      return -1;
        -:   51:    }
        -:   52:
        -:   53:  //set number of players
      600:   54:  state->numPlayers = numPlayers;
        -:   55:
        -:   56:  //check selected kingdom cards are different
     6600:   57:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   58:    {
    66000:   59:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   60:        {
    60000:   61:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   62:	    {
    #####:   63:	      return -1;
        -:   64:	    }
        -:   65:        }
        -:   66:    }
        -:   67:
        -:   68:
        -:   69:  //initialize supply
        -:   70:  ///////////////////////////////
        -:   71:
        -:   72:  //set number of Curse cards
      600:   73:  if (numPlayers == 2)
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
        -:   74:    {
      185:   75:      state->supplyCount[curse] = 10;
        -:   76:    }
      415:   77:  else if (numPlayers == 3)
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        -:   78:    {
      195:   79:      state->supplyCount[curse] = 20;
        -:   80:    }
        -:   81:  else
        -:   82:    {
      220:   83:      state->supplyCount[curse] = 30;
        -:   84:    }
        -:   85:
        -:   86:  //set number of Victory cards
      600:   87:  if (numPlayers == 2)
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
        -:   88:    {
      185:   89:      state->supplyCount[estate] = 8;
      185:   90:      state->supplyCount[duchy] = 8;
      185:   91:      state->supplyCount[province] = 8;
        -:   92:    }
        -:   93:  else
        -:   94:    {
      415:   95:      state->supplyCount[estate] = 12;
      415:   96:      state->supplyCount[duchy] = 12;
      415:   97:      state->supplyCount[province] = 12;
        -:   98:    }
        -:   99:
        -:  100:  //set number of Treasure cards
      600:  101:  state->supplyCount[copper] = 60 - (7 * numPlayers);
      600:  102:  state->supplyCount[silver] = 40;
      600:  103:  state->supplyCount[gold] = 30;
        -:  104:
        -:  105:  //set number of Kingdom cards
    12600:  106:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  107:    {
    99000:  108:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  109:	{
    93000:  110:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  111:	    {
        -:  112:	      //check if card is a 'Victory' Kingdom card
     6000:  113:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  114:		{
     1200:  115:		  if (numPlayers == 2){ 
branch  0 taken 31% (fallthrough)
branch  1 taken 69%
      185:  116:		    state->supplyCount[i] = 8; 
        -:  117:		  }
      415:  118:		  else{ state->supplyCount[i] = 12; }
        -:  119:		}
        -:  120:	      else
        -:  121:		{
     5400:  122:		  state->supplyCount[i] = 10;
        -:  123:		}
     6000:  124:	      break;
        -:  125:	    }
        -:  126:	  else    //card is not in the set choosen for the game
        -:  127:	    {
    87000:  128:	      state->supplyCount[i] = -1;
        -:  129:	    }
        -:  130:	}
        -:  131:
        -:  132:    }
        -:  133:
        -:  134:  ////////////////////////
        -:  135:  //supply intilization complete
        -:  136:
        -:  137:  //set player decks
     2435:  138:  for (i = 0; i < numPlayers; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  139:    {
     1835:  140:      state->deckCount[i] = 0;
     7340:  141:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  142:	{
     5505:  143:	  state->deck[i][j] = estate;
     5505:  144:	  state->deckCount[i]++;
        -:  145:	}
    14680:  146:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  147:	{
    12845:  148:	  state->deck[i][j] = copper;
    12845:  149:	  state->deckCount[i]++;		
        -:  150:	}
        -:  151:    }
        -:  152:
        -:  153:  //shuffle player decks
     2435:  154:  for (i = 0; i < numPlayers; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  155:    {
     1835:  156:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  157:	{
    #####:  158:	  return -1;
        -:  159:	}
        -:  160:    }
        -:  161:
        -:  162:  //draw player hands
     2435:  163:  for (i = 0; i < numPlayers; i++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  164:    {  
        -:  165:      //initialize hand size to zero
     1835:  166:      state->handCount[i] = 0;
     1835:  167:      state->discardCount[i] = 0;
        -:  168:      //draw 5 cards
        -:  169:      // for (j = 0; j < 5; j++)
        -:  170:      //	{
        -:  171:      //	  drawCard(i, state);
        -:  172:      //	}
        -:  173:    }
        -:  174:  
        -:  175:  //set embargo tokens to 0 for all supply piles
    16800:  176:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  177:    {
    16200:  178:      state->embargoTokens[i] = 0;
        -:  179:    }
        -:  180:
        -:  181:  //initialize first player's turn
      600:  182:  state->outpostPlayed = 0;
      600:  183:  state->phase = 0;
      600:  184:  state->numActions = 1;
      600:  185:  state->numBuys = 1;
      600:  186:  state->playedCardCount = 0;
      600:  187:  state->whoseTurn = 0;
      600:  188:  state->handCount[state->whoseTurn] = 0;
        -:  189:  //int it; move to top
        -:  190:
        -:  191:  //Moved draw cards to here, only drawing at the start of a turn
     3600:  192:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
     3000:  193:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  194:  }
        -:  195:
      600:  196:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  197:
      600:  198:  return 0;
        -:  199:}
        -:  200:
function shuffle called 1835 returned 100% blocks executed 94%
     1835:  201:int shuffle(int player, struct gameState *state) {
        -:  202: 
        -:  203:
        -:  204:  int newDeck[MAX_DECK];
     1835:  205:  int newDeckPos = 0;
        -:  206:  int card;
        -:  207:  int i;
        -:  208:
     1835:  209:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  210:    return -1;
     1835:  211:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  212:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  213:
    22020:  214:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    18350:  215:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
    18350:  216:    newDeck[newDeckPos] = state->deck[player][card];
    18350:  217:    newDeckPos++;
    64090:  218:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
    45740:  219:      state->deck[player][i] = state->deck[player][i+1];
        -:  220:    }
    18350:  221:    state->deckCount[player]--;
        -:  222:  }
    20185:  223:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
    18350:  224:    state->deck[player][i] = newDeck[i];
    18350:  225:    state->deckCount[player]++;
        -:  226:  }
        -:  227:
     1835:  228:  return 0;
        -:  229:}
        -:  230:
function playCard called 0 returned 0% blocks executed 0%
    #####:  231:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  232:{	
        -:  233:  int card;
    #####:  234:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  235:
        -:  236:  //check if it is the right phase
    #####:  237:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  238:    {
    #####:  239:      return -1;
        -:  240:    }
        -:  241:	
        -:  242:  //check if player has enough actions
    #####:  243:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  244:    {
    #####:  245:      return -1;
        -:  246:    }
        -:  247:	
        -:  248:  //get card played
    #####:  249:  card = handCard(handPos, state);
call    0 never executed
        -:  250:	
        -:  251:  //check if selected card is an action
    #####:  252:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  253:    {
    #####:  254:      return -1;
        -:  255:    }
        -:  256:	
        -:  257:  //play card
    #####:  258:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  259:    {
    #####:  260:      return -1;
        -:  261:    }
        -:  262:	
        -:  263:  //reduce number of actions
    #####:  264:  state->numActions--;
        -:  265:
        -:  266:  //update coins (Treasure cards may be added with card draws)
    #####:  267:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  268:	
    #####:  269:  return 0;
        -:  270:}
        -:  271:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  272:int buyCard(int supplyPos, struct gameState *state) {
        -:  273:  int who;
        -:  274:  if (DEBUG){
        -:  275:    printf("Entering buyCard...\n");
        -:  276:  }
        -:  277:
        -:  278:  // I don't know what to do about the phase thing.
        -:  279:
    #####:  280:  who = state->whoseTurn;
        -:  281:
    #####:  282:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  283:    if (DEBUG)
        -:  284:      printf("You do not have any buys left\n");
    #####:  285:    return -1;
    #####:  286:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  287:    if (DEBUG)
        -:  288:      printf("There are not any of that type of card left\n");
    #####:  289:    return -1;
    #####:  290:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  291:    if (DEBUG) 
        -:  292:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  293:    return -1;
        -:  294:  } else {
    #####:  295:    state->phase=1;
        -:  296:    //state->supplyCount[supplyPos]--;
    #####:  297:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  298:  
    #####:  299:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  300:    state->numBuys--;
        -:  301:    if (DEBUG)
        -:  302:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  303:  }
        -:  304:
        -:  305:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  306:  //state->discardCount[who]++;
        -:  307:    
    #####:  308:  return 0;
        -:  309:}
        -:  310:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  311:int numHandCards(struct gameState *state) {
    #####:  312:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  313:}
        -:  314:
function handCard called 0 returned 0% blocks executed 0%
    #####:  315:int handCard(int handPos, struct gameState *state) {
    #####:  316:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  317:  return state->hand[currentPlayer][handPos];
        -:  318:}
        -:  319:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  320:int supplyCount(int card, struct gameState *state) {
    #####:  321:  return state->supplyCount[card];
        -:  322:}
        -:  323:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  324:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  325:  int i;
    #####:  326:  int count = 0;
        -:  327:
    #####:  328:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  329:    {
    #####:  330:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  331:    }
        -:  332:
    #####:  333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  334:    {
    #####:  335:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  336:    }
        -:  337:
    #####:  338:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  339:    {
    #####:  340:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  341:    }
        -:  342:
    #####:  343:  return count;
        -:  344:}
        -:  345:
function whoseTurn called 0 returned 0% blocks executed 0%
    #####:  346:int whoseTurn(struct gameState *state) {
    #####:  347:  return state->whoseTurn;
        -:  348:}
        -:  349:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  350:int endTurn(struct gameState *state) {
        -:  351:  int k;
        -:  352:  int i;
    #####:  353:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  354:  
        -:  355:  //Discard hand
    #####:  356:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  357:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  358:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  359:  }
    #####:  360:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  361:    
        -:  362:  //Code for determining the player
    #####:  363:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  364:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  365:  }
        -:  366:  else{
    #####:  367:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  368:  }
        -:  369:
    #####:  370:  state->outpostPlayed = 0;
    #####:  371:  state->phase = 0;
    #####:  372:  state->numActions = 1;
    #####:  373:  state->coins = 0;
    #####:  374:  state->numBuys = 1;
    #####:  375:  state->playedCardCount = 0;
    #####:  376:  state->handCount[state->whoseTurn] = 0;
        -:  377:
        -:  378:  //int k; move to top
        -:  379:  //Next player draws hand
    #####:  380:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  381:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  382:  }
        -:  383:
        -:  384:  //Update money
    #####:  385:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  386:
    #####:  387:  return 0;
        -:  388:}
        -:  389:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  390:int isGameOver(struct gameState *state) {
        -:  391:  int i;
        -:  392:  int j;
        -:  393:	
        -:  394:  //if stack of Province cards is empty, the game ends
    #####:  395:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  396:    {
    #####:  397:      return 1;
        -:  398:    }
        -:  399:
        -:  400:  //if three supply pile are at 0, the game ends
    #####:  401:  j = 0;
    #####:  402:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  403:    {
    #####:  404:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  405:	{
    #####:  406:	  j++;
        -:  407:	}
        -:  408:    }
    #####:  409:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  410:    {
    #####:  411:      return 1;
        -:  412:    }
        -:  413:
    #####:  414:  return 0;
        -:  415:}
        -:  416:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  417:int scoreFor (int player, struct gameState *state) {
        -:  418:
        -:  419:  int i;
    #####:  420:  int score = 0;
        -:  421:  //score from hand
    #####:  422:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  423:    {
    #####:  424:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  425:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  430:    }
        -:  431:
        -:  432:  //score from discard
    #####:  433:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  434:    {
    #####:  435:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  436:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  441:    }
        -:  442:
        -:  443:  //score from deck
    #####:  444:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  445:    {
    #####:  446:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  447:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  452:    }
        -:  453:
    #####:  454:  return score;
        -:  455:}
        -:  456:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  457:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  458:  int i;	
        -:  459:  int j;
        -:  460:  int highScore;
        -:  461:  int currentPlayer;
        -:  462:
        -:  463:  //get score for each player
    #####:  464:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  465:    {
        -:  466:      //set unused player scores to -9999
    #####:  467:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  468:	{
    #####:  469:	  players[i] = -9999;
        -:  470:	}
        -:  471:      else
        -:  472:	{
    #####:  473:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  474:	}
        -:  475:    }
        -:  476:
        -:  477:  //find highest score
    #####:  478:  j = 0;
    #####:  479:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  480:    {
    #####:  481:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  482:	{
    #####:  483:	  j = i;
        -:  484:	}
        -:  485:    }
    #####:  486:  highScore = players[j];
        -:  487:
        -:  488:  //add 1 to players who had less turns
    #####:  489:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  490:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  491:    {
    #####:  492:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  493:	{
    #####:  494:	  players[i]++;
        -:  495:	}
        -:  496:    }
        -:  497:
        -:  498:  //find new highest score
    #####:  499:  j = 0;
    #####:  500:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  501:    {
    #####:  502:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  503:	{
    #####:  504:	  j = i;
        -:  505:	}
        -:  506:    }
    #####:  507:  highScore = players[j];
        -:  508:
        -:  509:  //set winners in array to 1 and rest to 0
    #####:  510:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  511:    {
    #####:  512:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  513:	{
    #####:  514:	  players[i] = 1;
        -:  515:	}
        -:  516:      else
        -:  517:	{
    #####:  518:	  players[i] = 0;
        -:  519:	}
        -:  520:    }
        -:  521:
    #####:  522:  return 0;
        -:  523:}
        -:  524:
function drawCard called 3000 returned 100% blocks executed 38%
     3000:  525:int drawCard(int player, struct gameState *state)
        -:  526:{	int count;
        -:  527:  int deckCounter;
     3000:  528:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  529:    
        -:  530:    //Step 1 Shuffle the discard pile back into a deck
        -:  531:    int i;
        -:  532:    //Move discard to deck
    #####:  533:    for (i = 0; i < state->discardCount[player];i++){
branch  0 never executed
branch  1 never executed
    #####:  534:      state->deck[player][i] = state->discard[player][i];
    #####:  535:      state->discard[player][i] = -1;
        -:  536:    }
        -:  537:
    #####:  538:    state->deckCount[player] = state->discardCount[player];
    #####:  539:    state->discardCount[player] = 0;//Reset discard
        -:  540:
        -:  541:    //Shufffle the deck
    #####:  542:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 never executed
        -:  543:   
        -:  544:    if (DEBUG){//Debug statements
        -:  545:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  546:    }
        -:  547:    
    #####:  548:    state->discardCount[player] = 0;
        -:  549:
        -:  550:    //Step 2 Draw Card
    #####:  551:    count = state->handCount[player];//Get current player's hand count
        -:  552:    
        -:  553:    if (DEBUG){//Debug statements
        -:  554:      printf("Current hand count: %d\n", count);
        -:  555:    }
        -:  556:    
    #####:  557:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  558:
    #####:  559:    if (deckCounter == 0)
branch  0 never executed
branch  1 never executed
    #####:  560:      return -1;
        -:  561:
    #####:  562:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
    #####:  563:    state->deckCount[player]--;
    #####:  564:    state->handCount[player]++;//Increment hand count
        -:  565:  }
        -:  566:
        -:  567:  else{
     3000:  568:    int count = state->handCount[player];//Get current hand count for player
        -:  569:    int deckCounter;
        -:  570:    if (DEBUG){//Debug statements
        -:  571:      printf("Current hand count: %d\n", count);
        -:  572:    }
        -:  573:
     3000:  574:    deckCounter = state->deckCount[player];//Create holder for the deck count
     3000:  575:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
     3000:  576:    state->deckCount[player]--;
     3000:  577:    state->handCount[player]++;//Increment hand count
        -:  578:  }
        -:  579:
     3000:  580:  return 0;
        -:  581:}
        -:  582:
function getCost called 0 returned 0% blocks executed 0%
    #####:  583:int getCost(int cardNumber)
        -:  584:{
    #####:  585:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  586:    {
        -:  587:    case curse:
    #####:  588:      return 0;
        -:  589:    case estate:
    #####:  590:      return 2;
        -:  591:    case duchy:
    #####:  592:      return 5;
        -:  593:    case province:
    #####:  594:      return 8;
        -:  595:    case copper:
    #####:  596:      return 0;
        -:  597:    case silver:
    #####:  598:      return 3;
        -:  599:    case gold:
    #####:  600:      return 6;
        -:  601:    case adventurer:
    #####:  602:      return 6;
        -:  603:    case council_room:
    #####:  604:      return 5;
        -:  605:    case feast:
    #####:  606:      return 4;
        -:  607:    case gardens:
    #####:  608:      return 4;
        -:  609:    case mine:
    #####:  610:      return 5;
        -:  611:    case remodel:
    #####:  612:      return 4;
        -:  613:    case smithy:
    #####:  614:      return 4;
        -:  615:    case village:
    #####:  616:      return 3;
        -:  617:    case baron:
    #####:  618:      return 4;
        -:  619:    case great_hall:
    #####:  620:      return 3;
        -:  621:    case minion:
    #####:  622:      return 5;
        -:  623:    case steward:
    #####:  624:      return 3;
        -:  625:    case tribute:
    #####:  626:      return 5;
        -:  627:    case ambassador:
    #####:  628:      return 3;
        -:  629:    case cutpurse:
    #####:  630:      return 4;
        -:  631:    case embargo: 
    #####:  632:      return 2;
        -:  633:    case outpost:
    #####:  634:      return 5;
        -:  635:    case salvager:
    #####:  636:      return 4;
        -:  637:    case sea_hag:
    #####:  638:      return 4;
        -:  639:    case treasure_map:
    #####:  640:      return 4;
        -:  641:    }
        -:  642:	
    #####:  643:  return -1;
        -:  644:}
        -:  645:
function playAdventurer called 0 returned 0% blocks executed 0%
    #####:  646:int playAdventurer(struct gameState *state, int currentPlayer, int handPos){
    #####:  647:  int drawntreasure=0;
        -:  648:  int cardDrawn;
        -:  649:  int temphand[MAX_HAND];
    #####:  650:  int z=0;
    #####:  651:  while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  652:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  653:      shuffle(currentPlayer, state);
call    0 never executed
        -:  654:    }
    #####:  655:    drawCard(currentPlayer, state);
call    0 never executed
    #####:  656:    cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
    #####:  657:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold ) //adding back the missing condition(gold) that Ken omitted
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  658:      drawntreasure++;
        -:  659:    else{
    #####:  660:      temphand[z]=cardDrawn;
    #####:  661:      state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
    #####:  662:      z++;
        -:  663:    }
        -:  664:  }
    #####:  665:  while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  666:	  state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  667:	  z=z-1;
        -:  668:  }
    #####:  669:  discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  670:  return 0;
        -:  671:}
        -:  672:
function playSmithy called 0 returned 0% blocks executed 0%
    #####:  673:int playSmithy(struct gameState *state, int currentPlayer, int handPos){
        -:  674:  //+3 Cards
        -:  675:  int i;
    #####:  676:  for (i = 0; i < 3; i++){
branch  0 never executed
branch  1 never executed
        -:  677:    //i=0;  Ken's bug, Fixing it by comment it out
    #####:  678:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  679:	}
        -:  680:			
        -:  681:  //discard card from hand
    #####:  682:  discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  683:  return 0;
        -:  684:}
        -:  685:
function playFeast called 0 returned 0% blocks executed 0%
    #####:  686:int playFeast(struct gameState *state, int currentPlayer, int handPos, int choice1){
        -:  687:  int i;
        -:  688:  int x;
        -:  689:  int temphand[MAX_HAND];
        -:  690:  //gain card with cost up to 5
        -:  691:  //Backup hand
    #####:  692:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  693:    temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  694:    state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  695:  }
        -:  696:  //Backup hand
        -:  697:
        -:  698:  //Update Coins for Buy
    #####:  699:  updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  700:  x = 1;//Condition to loop on
    #####:  701:  while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  702:	  if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  703:	    if (DEBUG){ 
        -:  704:        printf("None of that card left, sorry!\n");
        -:  705:      }
        -:  706:	  if (DEBUG){
        -:  707:	    printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  708:	  }
        -:  709:	}
    #####:  710:	else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  711:	  printf("That card is too expensive!\n");
call    0 never executed
        -:  712:
        -:  713:	  if (DEBUG){
        -:  714:	    printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  715:	  }
        -:  716:	}
        -:  717:	else{
        -:  718:
        -:  719:	  if (DEBUG){
        -:  720:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  721:	  }
        -:  722:
    #####:  723:	  gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  724:	  x = 0;//No more buying cards
        -:  725:
        -:  726:	  if (DEBUG){
        -:  727:	    printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  728:	  }
        -:  729:
        -:  730:	}
        -:  731:      }     
        -:  732:
        -:  733:      //Reset Hand
    #####:  734:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  735:	  state->hand[currentPlayer][i] = temphand[i];
    #####:  736:	  temphand[i] = -1;
        -:  737:  }
        -:  738:  //Reset Hand
        -:  739:      			
    #####:  740:  return 0;
        -:  741:}
        -:  742:
function playCouncilRoom called 0 returned 0% blocks executed 0%
    #####:  743:int playCouncilRoom(struct gameState *state, int currentPlayer, int handPos){
    #####:  744:  int i=0;
        -:  745:  //+4 Cards
    #####:  746:  for (i = 0; i < 4; i++){ drawCard(currentPlayer, state); }
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  747:  
        -:  748:  //+1 Buy
    #####:  749:  state->numBuys++;
        -:  750:  
        -:  751:  //Each other player draws a card
    #####:  752:  for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####:  753:	if( i != currentPlayer) //adding back the if statement that Ken ommitted 
branch  0 never executed
branch  1 never executed
        -:  754:	{
    #####:  755:    		drawCard(i, state);
call    0 never executed
        -:  756:	}
        -:  757:  }
        -:  758:  
        -:  759:  //put played card in played card pile
    #####:  760:  discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  761:  
    #####:  762:  return 0;
        -:  763:}
        -:  764:
function playVillage called 0 returned 0% blocks executed 0%
    #####:  765:int playVillage(struct gameState *state, int currentPlayer, int handPos){
        -:  766:  //+1 Card
    #####:  767:  drawCard(currentPlayer, state);
call    0 never executed
        -:  768:  
        -:  769:  //+2 Actions
    #####:  770:  state->numActions = state->numActions + 2;
        -:  771:  
        -:  772:  //discard played card from hand
        -:  773:  //discardCard(handPos, currentPlayer, state, 0);
    #####:  774:  return 0;	
        -:  775:}
        -:  776:
function cardEffect called 0 returned 0% blocks executed 0%
    #####:  777:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus){
        -:  778:  int i;
        -:  779:  int j;
        -:  780:  int k;
        -:  781:  int x;
        -:  782:  int index;
    #####:  783:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  784:  int nextPlayer = currentPlayer + 1;
        -:  785:
    #####:  786:  int tributeRevealedCards[2] = {-1, -1};
        -:  787:  int temphand[MAX_HAND];// moved above the if statement
    #####:  788:  int drawntreasure=0;
        -:  789:  int cardDrawn;
    #####:  790:  int z = 0;// this is the counter for the temp hand
    #####:  791:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 never executed
branch  1 never executed
    #####:  792:    nextPlayer = 0;
        -:  793:  }
        -:  794:  
        -:  795:	
        -:  796:  //uses switch to select card and perform actions
    #####:  797:  switch( card ){
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
        -:  798:    case adventurer:
    #####:  799:      return playAdventurer(state, currentPlayer, handPos);
call    0 never executed
        -:  800:			
        -:  801:    case council_room:
    #####:  802:      return playCouncilRoom(state, currentPlayer, handPos);
call    0 never executed
        -:  803:			
        -:  804:    case feast:
    #####:  805:      return playFeast(state, currentPlayer, handPos, choice1);
call    0 never executed
        -:  806:			
        -:  807:    case gardens:
    #####:  808:      return -1;
        -:  809:			
        -:  810:    case mine:
    #####:  811:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  812:
    #####:  813:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  814:	{
    #####:  815:	  return -1;
        -:  816:	}
        -:  817:		
    #####:  818:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  819:	{
    #####:  820:	  return -1;
        -:  821:	}
        -:  822:
    #####:  823:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  824:	{
    #####:  825:	  return -1;
        -:  826:	}
        -:  827:
    #####:  828:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  829:
        -:  830:      //discard card from hand
    #####:  831:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  832:
        -:  833:      //discard trashed card
    #####:  834:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  835:	{
    #####:  836:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  837:	    {
    #####:  838:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  839:	      break;
        -:  840:	    }
        -:  841:	}
        -:  842:			
    #####:  843:      return 0;
        -:  844:			
        -:  845:    case remodel:
    #####:  846:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  847:
    #####:  848:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  849:	{
    #####:  850:	  return -1;
        -:  851:	}
        -:  852:
    #####:  853:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  854:
        -:  855:      //discard card from hand
    #####:  856:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  857:
        -:  858:      //discard trashed card
    #####:  859:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  860:	{
    #####:  861:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  862:	    {
    #####:  863:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  864:	      break;
        -:  865:	    }
        -:  866:	}
        -:  867:
        -:  868:
    #####:  869:      return 0;
        -:  870:		
        -:  871:    case smithy:
    #####:  872:      return playSmithy(state, currentPlayer, handPos);
call    0 never executed
        -:  873:		
        -:  874:    case village:
    #####:  875:      return playVillage(state, currentPlayer, handPos);
call    0 never executed
        -:  876:
        -:  877:    case baron:
    #####:  878:      state->numBuys++;//Increase buys by 1!
    #####:  879:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####:  880:	int p = 0;//Iterator for hand!
    #####:  881:	int card_not_discarded = 1;//Flag for discard set!
    #####:  882:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####:  883:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####:  884:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####:  885:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####:  886:	    state->discardCount[currentPlayer]++;
    #####:  887:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####:  888:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -:  889:	    }
    #####:  890:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  891:	    state->handCount[currentPlayer]--;
    #####:  892:	    card_not_discarded = 0;//Exit the loop
        -:  893:	  }
    #####:  894:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -:  895:	    if(DEBUG) {
        -:  896:	      printf("No estate cards in your hand, invalid choice\n");
        -:  897:	      printf("Must gain an estate if there are any\n");
        -:  898:	    }
    #####:  899:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  900:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####:  901:	      state->supplyCount[estate]--;//Decrement estates
    #####:  902:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  903:		isGameOver(state);
call    0 never executed
        -:  904:	      }
        -:  905:	    }
    #####:  906:	    card_not_discarded = 0;//Exit the loop
        -:  907:	  }
        -:  908:			    
        -:  909:	  else{
    #####:  910:	    p++;//Next card
        -:  911:	  }
        -:  912:	}
        -:  913:      }
        -:  914:			    
        -:  915:      else{
    #####:  916:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  917:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####:  918:	  state->supplyCount[estate]--;//Decrement Estates
    #####:  919:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  920:	    isGameOver(state);
call    0 never executed
        -:  921:	  }
        -:  922:	}
        -:  923:      }
        -:  924:	    
        -:  925:      
    #####:  926:      return 0;
        -:  927:		
        -:  928:    case great_hall:
        -:  929:      //+1 Card
    #####:  930:      drawCard(currentPlayer, state);
call    0 never executed
        -:  931:			
        -:  932:      //+1 Actions
    #####:  933:      state->numActions++;
        -:  934:			
        -:  935:      //discard card from hand
    #####:  936:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####:  937:      return 0;
        -:  938:		
        -:  939:    case minion:
        -:  940:      //+1 action
    #####:  941:      state->numActions++;
        -:  942:			
        -:  943:      //discard card from hand
    #####:  944:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  945:			
    #####:  946:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -:  947:	{
    #####:  948:	  state->coins = state->coins + 2;
        -:  949:	}
        -:  950:			
    #####:  951:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -:  952:	{
        -:  953:	  //discard hand
    #####:  954:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  955:	    {
    #####:  956:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  957:	    }
        -:  958:				
        -:  959:	  //draw 4
    #####:  960:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  961:	    {
    #####:  962:	      drawCard(currentPlayer, state);
call    0 never executed
        -:  963:	    }
        -:  964:				
        -:  965:	  //other players discard hand and redraw if hand size > 4
    #####:  966:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  967:	    {
    #####:  968:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -:  969:		{
    #####:  970:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -:  971:		    {
        -:  972:		      //discard hand
    #####:  973:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -:  974:			{
    #####:  975:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -:  976:			}
        -:  977:							
        -:  978:		      //draw 4
    #####:  979:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -:  980:			{
    #####:  981:			  drawCard(i, state);
call    0 never executed
        -:  982:			}
        -:  983:		    }
        -:  984:		}
        -:  985:	    }
        -:  986:				
        -:  987:	}
    #####:  988:      return 0;
        -:  989:		
        -:  990:    case steward:
    #####:  991:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -:  992:	{
        -:  993:	  //+2 cards
    #####:  994:	  drawCard(currentPlayer, state);
call    0 never executed
    #####:  995:	  drawCard(currentPlayer, state);
call    0 never executed
        -:  996:	}
    #####:  997:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -:  998:	{
        -:  999:	  //+2 coins
    #####: 1000:	  state->coins = state->coins + 2;
        -: 1001:	}
        -: 1002:      else
        -: 1003:	{
        -: 1004:	  //trash 2 cards in hand
    #####: 1005:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1006:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1007:	}
        -: 1008:			
        -: 1009:      //discard card from hand
    #####: 1010:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1011:      return 0;
        -: 1012:		
        -: 1013:    case tribute:
    #####: 1014:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1015:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1016:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1017:	  state->deckCount[nextPlayer]--;
        -: 1018:	}
    #####: 1019:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1020:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1021:	  state->discardCount[nextPlayer]--;
        -: 1022:	}
        -: 1023:	else{
        -: 1024:	  //No Card to Reveal
        -: 1025:	  if (DEBUG){
        -: 1026:	    printf("No cards to reveal\n");
        -: 1027:	  }
        -: 1028:	}
        -: 1029:      }
        -: 1030:	    
        -: 1031:      else{
    #####: 1032:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1033:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1034:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1035:	    state->deckCount[nextPlayer]++;
    #####: 1036:	    state->discard[nextPlayer][i] = -1;
    #####: 1037:	    state->discardCount[nextPlayer]--;
        -: 1038:	  }
        -: 1039:			    
    #####: 1040:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1041:	} 
    #####: 1042:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1043:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1044:	state->deckCount[nextPlayer]--;
    #####: 1045:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1046:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1047:	state->deckCount[nextPlayer]--;
        -: 1048:      }    
        -: 1049:		       
    #####: 1050:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1051:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1052:	state->playedCardCount++;
    #####: 1053:	tributeRevealedCards[1] = -1;
        -: 1054:      }
        -: 1055:
    #####: 1056:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1057:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1058:	  state->coins += 2;
        -: 1059:	}
        -: 1060:		    
    #####: 1061:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1062:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1063:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1064:	}
        -: 1065:	else{//Action Card
    #####: 1066:	  state->numActions = state->numActions + 2;
        -: 1067:	}
        -: 1068:      }
        -: 1069:	    
    #####: 1070:      return 0;
        -: 1071:		
        -: 1072:    case ambassador:
    #####: 1073:      j = 0;		//used to check if player has enough cards to discard
        -: 1074:
    #####: 1075:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1076:	{
    #####: 1077:	  return -1;				
        -: 1078:	}
        -: 1079:
    #####: 1080:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1081:	{
    #####: 1082:	  return -1;
        -: 1083:	}
        -: 1084:
    #####: 1085:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1086:	{
    #####: 1087:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1088:	    {
    #####: 1089:	      j++;
        -: 1090:	    }
        -: 1091:	}
    #####: 1092:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1093:	{
    #####: 1094:	  return -1;				
        -: 1095:	}
        -: 1096:
        -: 1097:      if (DEBUG) 
        -: 1098:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1099:
        -: 1100:      //increase supply count for choosen card by amount being discarded
    #####: 1101:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1102:			
        -: 1103:      //each other player gains a copy of revealed card
    #####: 1104:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1105:	{
    #####: 1106:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1107:	    {
    #####: 1108:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1109:	    }
        -: 1110:	}
        -: 1111:
        -: 1112:      //discard played card from hand
    #####: 1113:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1114:
        -: 1115:      //trash copies of cards returned to supply
    #####: 1116:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1117:	{
    #####: 1118:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1119:	    {
    #####: 1120:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1121:		{
    #####: 1122:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1123:		  break;
        -: 1124:		}
        -: 1125:	    }
        -: 1126:	}			
        -: 1127:
    #####: 1128:      return 0;
        -: 1129:		
        -: 1130:    case cutpurse:
        -: 1131:
    #####: 1132:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1133:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1134:	{
    #####: 1135:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1136:	    {
    #####: 1137:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1138:		{
    #####: 1139:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1140:		    {
    #####: 1141:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1142:		      break;
        -: 1143:		    }
    #####: 1144:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1145:		    {
    #####: 1146:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1147:			{
        -: 1148:			  if (DEBUG)
        -: 1149:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1150:			}	
    #####: 1151:		      break;
        -: 1152:		    }		
        -: 1153:		}
        -: 1154:					
        -: 1155:	    }
        -: 1156:				
        -: 1157:	}				
        -: 1158:
        -: 1159:      //discard played card from hand
    #####: 1160:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1161:
    #####: 1162:      return 0;
        -: 1163:
        -: 1164:		
        -: 1165:    case embargo: 
        -: 1166:      //+2 Coins
    #####: 1167:      state->coins = state->coins + 2;
        -: 1168:			
        -: 1169:      //see if selected pile is in play
    #####: 1170:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1171:	{
    #####: 1172:	  return -1;
        -: 1173:	}
        -: 1174:			
        -: 1175:      //add embargo token to selected supply pile
    #####: 1176:      state->embargoTokens[choice1]++;
        -: 1177:			
        -: 1178:      //trash card
    #####: 1179:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1180:      return 0;
        -: 1181:		
        -: 1182:    case outpost:
        -: 1183:      //set outpost flag
    #####: 1184:      state->outpostPlayed++;
        -: 1185:			
        -: 1186:      //discard card
    #####: 1187:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1188:      return 0;
        -: 1189:		
        -: 1190:    case salvager:
        -: 1191:      //+1 buy
    #####: 1192:      state->numBuys++;
        -: 1193:			
    #####: 1194:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1195:	{
        -: 1196:	  //gain coins equal to trashed card
    #####: 1197:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1198:	  //trash card
    #####: 1199:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1200:	}
        -: 1201:			
        -: 1202:      //discard card
    #####: 1203:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1204:      return 0;
        -: 1205:		
        -: 1206:    case sea_hag:
    #####: 1207:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1208:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1209:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1210:	  state->discardCount[i]++;
    #####: 1211:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1212:	}
        -: 1213:      }
    #####: 1214:      return 0;
        -: 1215:		
        -: 1216:    case treasure_map:
        -: 1217:      //search hand for another treasure_map
    #####: 1218:      index = -1;
    #####: 1219:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1220:	{
    #####: 1221:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1222:	    {
    #####: 1223:	      index = i;
    #####: 1224:	      break;
        -: 1225:	    }
        -: 1226:	}
    #####: 1227:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1228:	{
        -: 1229:	  //trash both treasure cards
    #####: 1230:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1231:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1232:
        -: 1233:	  //gain 4 Gold cards
    #####: 1234:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1235:	    {
    #####: 1236:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1237:	    }
        -: 1238:				
        -: 1239:	  //return success
    #####: 1240:	  return 1;
        -: 1241:	}
        -: 1242:			
        -: 1243:      //no second treasure_map found in hand
    #####: 1244:      return -1;
        -: 1245:    }
        -: 1246:	
    #####: 1247:  return -1;
        -: 1248:}
        -: 1249:
function discardCard called 0 returned 0% blocks executed 0%
    #####: 1250:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1251:{
        -: 1252:	
        -: 1253:  //if card is not trashed, added to Played pile 
    #####: 1254:  if (trashFlag < 1)
branch  0 never executed
branch  1 never executed
        -: 1255:    {
        -: 1256:      //add card to played pile
    #####: 1257:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1258:      state->playedCardCount++;
        -: 1259:    }
        -: 1260:	
        -: 1261:  //set played card to -1
    #####: 1262:  state->hand[currentPlayer][handPos] = -1;
        -: 1263:	
        -: 1264:  //remove card from player's hand
    #####: 1265:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 never executed
branch  1 never executed
        -: 1266:    {
        -: 1267:      //reduce number of cards in hand
    #####: 1268:      state->handCount[currentPlayer]--;
        -: 1269:    }
    #####: 1270:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 never executed
branch  1 never executed
        -: 1271:    {
        -: 1272:      //reduce number of cards in hand
    #####: 1273:      state->handCount[currentPlayer]--;
        -: 1274:    }
        -: 1275:  else 	
        -: 1276:    {
        -: 1277:      //replace discarded card with last card in hand
    #####: 1278:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1279:      //set last card to -1
    #####: 1280:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1281:      //reduce number of cards in hand
    #####: 1282:      state->handCount[currentPlayer]--;
        -: 1283:    }
        -: 1284:	
    #####: 1285:  return 0;
        -: 1286:}
        -: 1287:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1288:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1289:{
        -: 1290:  //Note: supplyPos is enum of choosen card
        -: 1291:	
        -: 1292:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1293:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1294:    {
    #####: 1295:      return -1;
        -: 1296:    }
        -: 1297:	
        -: 1298:  //added card for [whoseTurn] current player:
        -: 1299:  // toFlag = 0 : add to discard
        -: 1300:  // toFlag = 1 : add to deck
        -: 1301:  // toFlag = 2 : add to hand
        -: 1302:
    #####: 1303:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1304:    {
    #####: 1305:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1306:      state->deckCount[player]++;
        -: 1307:    }
    #####: 1308:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1309:    {
    #####: 1310:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1311:      state->handCount[player]++;
        -: 1312:    }
        -: 1313:  else
        -: 1314:    {
    #####: 1315:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1316:      state->discardCount[player]++;
        -: 1317:    }
        -: 1318:	
        -: 1319:  //decrease number in supply pile
    #####: 1320:  state->supplyCount[supplyPos]--;
        -: 1321:	 
    #####: 1322:  return 0;
        -: 1323:}
        -: 1324:
function updateCoins called 600 returned 100% blocks executed 82%
      600: 1325:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1326:{
        -: 1327:  int i;
        -: 1328:	
        -: 1329:  //reset coin count
      600: 1330:  state->coins = 0;
        -: 1331:
        -: 1332:  //add coins for each Treasure card in player's hand
     3600: 1333:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1334:    {
     3000: 1335:      if (state->hand[player][i] == copper)
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1336:	{
     2400: 1337:	  state->coins += 1;
        -: 1338:	}
      600: 1339:      else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1340:	{
    #####: 1341:	  state->coins += 2;
        -: 1342:	}
      600: 1343:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1344:	{
    #####: 1345:	  state->coins += 3;
        -: 1346:	}	
        -: 1347:    }	
        -: 1348:
        -: 1349:  //add bonus
      600: 1350:  state->coins += bonus;
        -: 1351:
      600: 1352:  return 0;
        -: 1353:}
        -: 1354:
        -: 1355:
        -: 1356://end of dominion.c
        -: 1357:
